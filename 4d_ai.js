/*TO DO:
	-Trade-off rules need to account for experience.
	-Add probabilistic behaviour.
	-Awareness of 'blocking' (move a unit in front of another unit to protect it.) (And making friendly units vulnerable when moving a unit.)
*/

//Creates a new ai with the given difficulty level.
function AI(playerNumber, difficulty){
	this.playerNum = playerNumber;
	this.opponentNum = 1;
	this.difficulty = difficulty;
	this.unitPriority = ["King","Queen","Rook","Bishop","Knight","Pawn"];
}

AI.prototype.decideNew = function(){
	
	//Update possible moves.
	this.aiMoves = this.getMoves(window.game.activeBoard, this.playerNum);
	this.aiWarps = this.getWarps(window.game.activeBoard, this.playerNum);
	this.opponentMoves = this.getMoves(window.game.activeBoard, this.opponentNum);
	this.opponentWarps = this.getWarps(window.game.otherBoard, this.opponentNum);

	//Select best move and do it.
	var bestMove = this.prioritizeMoves(this.aiMoves);
	var unit = bestMove[0];
	var target = bestMove[1][1];

	unit.move(target);
};

//Returns all possible moves for a turn on te given board with for the given player.
AI.prototype.getMoves = function(activeBoard, activePlayer){
	
	var grid  = window.game.boards[activeBoard].grid;
	var possibleMoves = new Array(); // Format: [[unit, [[board,[row,col]] ,..] ],...]
	//Get units on board.
	for(var row = 0; row < grid.length; row++){
		for(var col = 0; col < grid[row].length; col++){
			curUnit = grid[row][col];

			//Get moves for relavent units.
			if(curUnit && curUnit.owner == activePlayer){
				var moves = curUnit.movementPath("predict");
				
				//If the piece has valid moves.
				if(moves.length){
					possibleMoves.push([curUnit, moves]);
				}
			}
		}
	}

	var warps = this.getWarps(window.game.activeBoard, this.playerNum);
	if(warps){
		possibleMoves.concat(warps);
	}

	return possibleMoves;
};


//Returns all possible moves for a turn on the given board with for the given player.
AI.prototype.getWarps = function(boardId, activePlayer){

	var grid  = window.game.boards[boardId].grid;
	var possibleWarps = new Array(); // Format: [[unit,arrayOfMoves],...]
	//Get units on board.
	for(var row = 0; row < grid.length; row++){
		for(var col = 0; col < grid[row].length; col++){
			curUnit = grid[row][col];

			//Get moves for relavent units.
			if(curUnit && curUnit.owner == activePlayer){
				var canWarp = (curUnit.experience >= 2);
				
				//If the piece has valid moves.
				if(canWarp){
					possibleWarps.push([curUnit, curUnit.position]);
				}
			}
		}
	}
	return possibleWarps;
};

//Takes a moveset array generated by getMoves and a moveSet generated by getWarps.
//Returns the best possible move.
AI.prototype.prioritizeMoves = function(moves){

	var bestMoves = null;
	var bestValue = null;

	for(var u = 0; u < moves.length; u++){
		for(var m = 0; m < moves[u][1].length; m++){
			
			var curUnit = moves[u][0];
			var curMove = moves[u][1][m];
			var curValue = 0;

			curValue = this.moveValue(curUnit, curMove);
				

			if(curValue == bestValue){
				bestMoves.push([curUnit, curMove]);

			}else if(bestMoves == null || curValue > bestValue){
				bestMoves = new Array([curUnit, curMove]);
				bestValue = curValue;
			}
		}
	}

	//If there is one best move, do it.
	if(bestMoves.length == 1){
		console.log("Unit moved:", bestMoves[0][0],"\n","Move value:", bestValue);
		return bestMoves[0];
	
	//If there is a tie, pick a random one.
	}else{
		var randomIndex = Math.floor(Math.random()*bestMoves.length);

		console.log("Unit moved:", bestMoves[randomIndex][0],"\n","Move value:", bestValue);
		return bestMoves[randomIndex];
	}
};

//Does curMove intersect with any move in the moveSet?
AI.prototype.intersect = function(curMove, moveSet){

	for(var i = 0; i < moveSet.length; i++){

		for(var j = 0; j < moveSet[i][1].length; j++){

			var setMove = moveSet[i][1][j][1];
			if(setMove[0] == curMove[0] && setMove[1] == curMove[1]){
				//console.log("Intersecting unit:", moveSet[unit][0]);
				return true;
			}
		}
	}
	return false;
};

//Is this position guarded?
//Board is the board to check
//Position is the position to check.
//guardOwner is the playerNum of the player who would own the guards.
AI.prototype.guarded = function(boardIndex, position, guardOwner){
	var board = window.game.boards[boardIndex];
	var grid = board.grid;
	var tempOwner = null;

	if(guardOwner == this.playerNum){
		tempOwner = this.opponentNum;
	}else{
		tempOwner = this.playerNum;
	}

	 var existingUnit = null;
	 if(grid[position[0]][position[1]]){
	 	existingUnit = grid[position[0]][position[1]];
	 }

	//Replace unit with an enemy.
	grid[position[0]][position[1]] = new Pawn(tempOwner, board, position[0], position[1]);
	//Get moves as if it were gone.
	var tempMoves = this.getMoves(board.boardId, guardOwner);
	//Return board to original state.
	grid[position[0]][position[1]] = existingUnit;

	return this.intersect(position, tempMoves);
}

//Returns the value of a move.
AI.prototype.moveValue = function(myUnit, move){

	var targetBoard = move[0];
	var target = move[1];

	//Is this unit in danger right now?
	var danger = this.intersect(myUnit.position, this.opponentMoves);
	//Is the target tile guarded?
	var guarded = this.guarded(targetBoard, target, this.opponentNum);
	var myValue = this.pawnValue(myUnit);
	var totalValue = 0;
	
	var boardIndex = window.game.activeBoard;
	var opponentUnit = window.game.boards[boardIndex].grid[target[0]][target[1]];
	
	//If a capture will be made, find the value of the capture.
	if(opponentUnit){
		totalValue += this.pawnValue(opponentUnit);
	}

	//If the target is guarded the unit will be captured, so we lose it's value.
	if(guarded){
		totalValue  -= myValue;
	
	//If the unit is in danger, moving it to an unguarded tile will 'save' it.
	}else if(!guarded && danger){
		totalValue += myValue;
	}

	return totalValue;
};


AI.prototype.pawnValue = function(unit){
	var unitValue = 0;

	switch(unit.constructor.name){
		case "Pawn":
			unitValue = 1;
			break;
		case "Knight":
			unitValue = 3;
			break;
		case "Bishop":
			unitValue = 3;
			break;
		case "Rook":
			unitValue = 5;
			break;
		case "Queen":
			unitValue = 9;
			break;
		case "King":
			unitValue = 1000;
			break;
	}
	return unitValue;
};